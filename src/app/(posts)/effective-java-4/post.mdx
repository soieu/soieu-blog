# ITEM4. 인스턴스화를 막으려거든 private 생성자를 사용하라

### 언제?

1. **기본 타입 값이나 배열 관련 메서드의 집합**
   - 기본 타입 값이나 배열 작업과 관련된 정적 메서드만 포함된 클래스에서 객체 생성을 방지해야 한다.
   - 예: `java.lang.Math`, `java.util.Arrays`
2. **특정 인터페이스를 구현하는 객체를 생성해 주는 정적 메서드의 집합**
   - 특정 인터페이스를 구현하는 객체를 생성해 반환하는 정적 메서드만 제공하는 클래스에서 객체 생성을 방지해야 한다.
   - 예: `java.util.Collections`
3. **`final` 클래스와 관련된 메서드의 집합**
   - final 클래스와 관련한 메서드들을 모아놓을 때 → final 클래스를 상속해서 하위 클래스에 메서드를 넣는 것이 불가능하기 때문에
   - 이거 뭔소리인지 이해안간다
   - 상속이 불가능해서 하위클래스에서 메서드를 넣는게 불가능하다는건 이해가간다.. 그런데 이게 왜 private 생성자를 이용해야할 이유인가? 클래스 용도를 명확히전달? 이거같긴하다

### 왜 private 생성자를 사용해야 하는가?

1. **기본 생성자가 자동으로 생성된다**
   - 생성자를 명시적으로 정의하지 않으면 컴파일러가 기본 public 생성자를 자동으로 추가한다.
   - 이는 외부에서 객체 생성을 허용하여, 클래스의 본래 의도와 어긋난다.
2. **클래스의 용도를 명확히 전달할 수 있다**
   - 객체 생성을 방지하면 해당 클래스가 **인스턴스를 생성하기 위한 것이 아님**을 명확히 전달할 수 있다.
   - 이는 설계 의도를 분명히 하고, 코드의 가독성과 유지보수성을 높인다.
3. **잘못된 사용을 방지한다**
   - 객체 생성을 허용하면 불필요한 메모리 낭비와 리소스 오용의 가능성이 생긴다.
   - `private` 생성자를 통해 이를 원천 차단할 수 있다.

export const metadata = {
  title: "ITEM4. 인스턴스화를 막으려거든 private 생성자를 사용하라",
  createdAt: "2024-11-22T21:32:00Z",
  tags: ["Java", "Effective-Java"],
};

;
